// This file was supplied by Prof. Marshall Long for ENAS 130 and has been
// updated in minor ways by Dr. Beth Anne Bennett.

#include <QApplication>
#include "classVertex.h"
#include "structPoly_classSolid.h"
#include "finalgraphics.h"
#include "finalgraphicswindow.h"
#include "ui_finalgraphicswindow.h" // will be automatically generated by Qt
                                    // and will appear in the build folder

/*
Define graphics functions as follows:

void plotOn(int height, int width)   Open a window of specified size (in pixels).

void xScale(float xmin, float xmax)  Scale the window's x-axis.

void yScale(float ymin, float ymax)  Scale the window's y-axis.

void setPen(float x, float y)        Place the pen at location (x,y).

void drawLineSeg(float x, float y)   Draw a line segment to location (x,y).
                                     Leave the pen at location (x,y).

void drawCross(float x, float y)     Draw a cross at location (x,y).
                                     Leave the pen at location (x,y).

void drawPoly(Vertex* verticesToDraw, int numVertices, int fillColor, float intensity)
              Draw a polygon.
              verticesToDraw is an array containing at least numVertices Vertex objects.
              numVertices is between 3 and 10, inclusive.
              fillColor is -1 (no fill), 0 (grey), 1 (red), 2 (green), 3 (blue), or 4 (purple).
              intensity is between 0. and 1., inclusive.

void drawRect(float x0, float y0, float x1, float y1, int fillColor, float intensity)
              Draw a rectangle with opposite corners (x0,y0) and (x1,y1).
              fillColor is -1 (no fill), 0 (grey), 1 (red), 2 (green), 3 (blue), or 4 (purple).
              intensity is between 0. and 1., inclusive.

void clear()              Erase everything in the window.

void updateImage()        Update the image with everything that has been drawn so far.

void delay(int centisecs) Delay for the specified number of hundredths of seconds.

int getMouse(float *px, float *py, int *pdrag)
              Get the xy coordinates of a mouse click.
              Scaling is as per xScale and yScale calls.
              Return value is the number of the button pressed or dragged.
              Values are 1 (LEFT_BUTTON), 2 (CENTER_BUTTON), or 3 (RIGHT_BUTTON).

int neitherRightClickNorRightDrag()  Return 1 unless the right mouse button has been
                                     clicked or dragged, in which case return 0.

int getAxis(int *paxis, float *pdir)
              Respond to mouse movement and provide info on how solid object should rotate.
              1st arg returns 1 or 2 (rotation about X or Y axis).
              2nd arg returns 1 or -1, indicating the direction of rotation.
              Return value is 1 unless the mouse has been clicked in the lower left corner
                  of the graphics window, in which case the return value is 0.
*/

extern GraphicsWindow *w2;

#define NUM_COLOR 5
#define SHADES 256
#define LX 4

float   xmin, xmax, ymin, ymax, xscalerange, scalex, yscalerange, scaley;
int     ix, iy;
int     ymaxim;
QColor  colors[NUM_COLOR][SHADES];
QPixmap *thePixMap;

void plotOn(int height, int width)
{
    if (height < 10) height = 10;
    if (width < 10) width = 10;

    scalex = width;
    scaley = height;
    ymaxim = height;

    w2->setGeometry(10, 10, width, height);
    w2->show();
    w2->setupPixmap(width, height);
    w2->update();

    getColors();

    return;
}

void xScale(float x, float y)
{
    xmin = x;
    xmax = y;
    xscalerange = scalex/(xmax-xmin);

    return;
}

void yScale(float x, float y)
{
    ymin = x;
    ymax = y;
    yscalerange = scaley/(ymax-ymin);

    return;
}

void setPen(float x, float y)
{
    ix = (int)((x-xmin)*xscalerange);
    iy = (int)((y-ymin)*yscalerange);
    iy = ymaxim - iy;

    return;
}

void drawLineSeg(float x, float y)
{
    int ix0, iy0;
    ix0 = ix;
    iy0 = iy;

    ix = (int)((x-xmin)*xscalerange);
    iy = (int)((y-ymin)*yscalerange);
    iy = ymaxim - iy;

    drawLine(ix0, iy0, ix, iy);

    return;
}

void drawLine(int x0, int y0, int x1, int y1)
{
    QPainter painter(thePixMap);
    painter.setCompositionMode(QPainter::CompositionMode_SourceOver);
    painter.setPen(QColor("black"));
    painter.drawLine(x0, y0, x1, y1);
    w2->update();

    return;
}

void drawCross(float x, float y)
{
    ix = (int)((x-xmin)*xscalerange);
    iy = (int)((y-ymin)*yscalerange);
    iy = ymaxim - iy;

    drawLine(ix-LX, iy-LX, ix+LX, iy+LX);
    drawLine(ix-LX, iy+LX, ix+LX, iy-LX);

    return;
}

void drawPoly(Vertex* verticesToDraw, int numVertices, int fillColor, float intensity)
{
    int j;
    QPoint ppoly[11];

    for (j=0; j<numVertices; j++)
        ppoly[j] = screenCoord(verticesToDraw[j]);

    if (fillColor >= 0 && fillColor < NUM_COLOR)
    {
        int shade = (int)(intensity*SHADES);
        if (shade>SHADES-1) shade = SHADES - 1;  // shouldn't happen

        QPainter painter(thePixMap);
        painter.setCompositionMode(QPainter::CompositionMode_SourceOver);
        painter.setBrush(colors[fillColor][shade]);
        painter.setPen(colors[fillColor][shade]);
        painter.drawPolygon(ppoly, numVertices);
    }
    else // draw the borders of this polygon in black
    {
        QPainter painter(thePixMap);
        painter.setCompositionMode(QPainter::CompositionMode_SourceOver);
        painter.setPen(Qt::black);
        painter.drawPolygon(ppoly, numVertices);
    }

    w2->update();

    return;
}

/*
void drawRect(float x0, float y0, float x1, float y1, int fillColor, float intensity)
{
    Vertex polygon[4];

    polygon[0].x = x0;
    polygon[0].y = y0;

    polygon[1].x = x1;
    polygon[1].y = y0;

    polygon[2].x = x1;
    polygon[2].y = y1;

    polygon[3].x = x0;
    polygon[3].y = y1;

    drawPoly(polygon, 4, fillColor, intensity);

    return;
}
*/

void clear()
{
    thePixMap->fill(Qt::white);
    w2->update();

    return;
}

void updateImage()
{
    extern QApplication *a2;
    a2->processEvents(QEventLoop::WaitForMoreEvents);

    return;
}

void delay(int centisecs)
{
    clock_t start;
    start = clock();
    while ((clock()- start)*100/CLOCKS_PER_SEC < (clock_t)centisecs);

    return;
}

int getMouse(float *px, float *py, int *pnotdone)
{
    extern float scaledX, scaledY;
    extern int mouseState;
    extern QApplication *a2;
    int button;

    // wait for mouse events
    while (mouseState == NO_BUTTON)
    {
        a2->processEvents(QEventLoop::WaitForMoreEvents);
    }

    *px = scaledX;
    *py = scaledY;

    if (mouseState <= RIGHT_BUTTON)  // click-only event
    {
        if ((*px > xmin + (xmax-xmin)*.1) || (*py > ymin + (ymax-ymin)*.1))
            *pnotdone = 1;
        else
            *pnotdone = 0;

        button = mouseState;  // button number is already in range 1 - 3
    }
    else  // drag-and-click event
    {
        *pnotdone = 1;
        button = mouseState - 3;  // get button number in range 1 - 3
    }

    mouseState = NO_BUTTON;  // reset mouseState

    return button;
}

int neitherRightClickNorRightDrag()
{
    extern int mouseState;
    if (mouseState == RIGHT_BUTTON || mouseState == RIGHT_MOVING)
        return 0;
    else
        return 1;
}

QPoint screenCoord(Vertex p)
{
    // scale the x and y components of a Vertex to screen
    return QPoint((int)((p.x-xmin)*xscalerange), ymaxim-(int)((p.y-ymin)*yscalerange));
}

void getColors()
{
    int intensity[SHADES];
    int colorindex, i;
    float cAmbient = 75;  // start the shades here -- provides ambient lighting

    // Do grayscale
    colorindex = 0;
    for (i=0; i<SHADES; i++)
    {
        intensity[i] = cAmbient+(255.-cAmbient)/SHADES*(i+1);
        colors[colorindex][i].setRgb(intensity[i], intensity[i], intensity[i], 255);
    }

    // Do red
    colorindex = 1;
    for (i=0; i<SHADES; i++)
    {
        colors[colorindex][i].setRgb(intensity[i], 0, 0, 255);
    }

    // Do green
    colorindex = 2;
    for (i=0; i<SHADES; i++)
    {
        colors[colorindex][i].setRgb(0, intensity[i], 0, 255);
    }

    // Do blue
    colorindex = 3;
    for (i=0; i<SHADES; i++)
    {
        colors[colorindex][i].setRgb(0, 0, intensity[i], 255);
    }

    // Do purple
    colorindex = 4;
    for (i=0; i<SHADES; i++)
    {
        colors[colorindex][i].setRgb(intensity[i], 0, intensity[i], 255);
    }

    return;
}

int getAxis(int *paxis, float *pdir)
{
    float x0, x1, y0, y1;
    int notdone;

    getMouse(&x0, &y0, &notdone);
    if (!notdone) return notdone;

    getMouse(&x1, &y1, &notdone);

    if (fabs(x1-x0) > fabs(y1-y0))
    {
        *paxis = Y;
        if (x1>x0)
            *pdir = 1.;
        else
            *pdir = -1;
    }
    else
    {
        *paxis = X;
        if (y1>y0)
            *pdir = -1.;
        else
            *pdir = 1.;
    }

    return notdone;
}

